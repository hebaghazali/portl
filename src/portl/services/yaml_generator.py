"""
YAML generator service for creating migration configuration files.

This service converts wizard responses and configuration dictionaries
into properly formatted YAML migration job files.
"""

from typing import Dict, Any, List
import yaml
from datetime import datetime
from ..schema import JobConfig, SchemaValidator


class YamlGenerator:
    """Generates YAML configuration files from wizard responses."""
    
    def generate_yaml(self, config: Dict[str, Any]) -> str:
        """
        Generate a YAML configuration file from wizard responses.
        
        Args:
            config: Configuration dictionary from wizard
            
        Returns:
            str: Formatted YAML content
        """
        # Create the YAML structure
        yaml_config = self._build_yaml_structure(config)
        
        # Generate YAML with comments
        yaml_content = self._generate_yaml_with_comments(yaml_config)
        
        return yaml_content
    
    def _build_yaml_structure(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Build the YAML structure from configuration."""
        yaml_config = {}
        
        # Add metadata
        yaml_config['# Generated by Portl Interactive Wizard'] = None
        yaml_config['# Created at'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        # Source configuration
        if 'source' in config:
            yaml_config['source'] = self._clean_config_section(config['source'])
        
        # Destination configuration
        if 'destination' in config:
            yaml_config['destination'] = self._clean_config_section(config['destination'])
        
        # Processing configuration
        if 'conflict' in config:
            yaml_config['conflict'] = config['conflict']
        
        if 'batch_size' in config:
            yaml_config['batch_size'] = config['batch_size']
        
        # Optional advanced configurations
        if 'schema_mapping' in config and config['schema_mapping']:
            yaml_config['schema_mapping'] = config['schema_mapping']
        
        if 'transformations' in config and config['transformations']:
            yaml_config['transformations'] = config['transformations']
        
        if 'hooks' in config and config['hooks']:
            yaml_config['hooks'] = config['hooks']
        
        # Add default parallel jobs if not specified
        if 'parallel_jobs' not in yaml_config:
            yaml_config['parallel_jobs'] = 1
        
        return yaml_config
    
    def _clean_config_section(self, section: Dict[str, Any]) -> Dict[str, Any]:
        """Clean and organize a configuration section."""
        cleaned = {}
        
        # Always put type first
        if 'type' in section:
            cleaned['type'] = section['type']
        
        # Add other keys in logical order
        key_order = [
            'host', 'port', 'database', 'username', 'password', 'schema', 'table', 'query',
            'path', 'spreadsheet_id', 'sheet_name', 'credentials_path'
        ]
        
        for key in key_order:
            if key in section:
                cleaned[key] = section[key]
        
        # Add any remaining keys
        for key, value in section.items():
            if key not in cleaned:
                cleaned[key] = value
        
        return cleaned
    
    def _generate_yaml_with_comments(self, config: Dict[str, Any]) -> str:
        """Generate YAML with helpful comments."""
        lines = []
        
        # Header comment
        lines.append("# Portl Migration Job Configuration")
        lines.append("# Generated by Interactive Wizard")
        lines.append(f"# Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append("")
        
        # Source section
        if 'source' in config:
            lines.append("# Source: Where to read data FROM")
            lines.extend(self._yaml_section_to_lines('source', config['source']))
            lines.append("")
        
        # Destination section
        if 'destination' in config:
            lines.append("# Destination: Where to write data TO")
            lines.extend(self._yaml_section_to_lines('destination', config['destination']))
            lines.append("")
        
        # Processing configuration
        lines.append("# Processing Configuration")
        
        if 'conflict' in config:
            lines.append("# How to handle conflicts when records already exist")
            lines.append("# Options: overwrite, skip, fail, merge")
            lines.append(f"conflict: {config['conflict']}")
            lines.append("")
        
        if 'batch_size' in config:
            lines.append("# Number of rows to process in each batch")
            lines.append(f"batch_size: {config['batch_size']}")
            lines.append("")
        
        if 'parallel_jobs' in config:
            lines.append("# Number of parallel processing jobs")
            lines.append(f"parallel_jobs: {config['parallel_jobs']}")
            lines.append("")
        
        # Optional sections
        if 'schema_mapping' in config:
            lines.append("# Column Mapping: source_column -> destination_column")
            lines.extend(self._yaml_section_to_lines('schema_mapping', config['schema_mapping']))
            lines.append("")
        
        if 'transformations' in config:
            lines.append("# Data Transformations")
            lines.extend(self._yaml_section_to_lines('transformations', config['transformations']))
            lines.append("")
        
        if 'hooks' in config:
            lines.append("# Processing Hooks: Scripts to run at different stages")
            lines.extend(self._yaml_section_to_lines('hooks', config['hooks']))
            lines.append("")
        
        return '\n'.join(lines)
    
    def _yaml_section_to_lines(self, section_name: str, section_data: Any) -> List[str]:
        """Convert a section to YAML lines."""
        # Use PyYAML to generate the section
        section_yaml = yaml.dump({section_name: section_data}, default_flow_style=False, sort_keys=False)
        
        # Split into lines and return (excluding the first line which is just the section name)
        lines = section_yaml.strip().split('\n')
        return lines
    
    def validate_generated_yaml(self, yaml_content: str) -> Dict[str, Any]:
        """
        Validate the generated YAML content using the schema validator.
        
        Args:
            yaml_content: YAML content to validate
            
        Returns:
            Dict with validation results
        """
        try:
            # Parse YAML to check syntax
            parsed = yaml.safe_load(yaml_content)
            
            if not parsed:
                return {
                    "valid": False,
                    "errors": ["YAML content is empty"],
                    "warnings": []
                }
            
            # Use the schema validator for comprehensive validation
            job_config = SchemaValidator.validate_yaml_config(parsed)
            
            # If we get here, validation passed
            validation_result = {
                "valid": True,
                "errors": [],
                "warnings": []
            }
            
            # Add warnings for missing optional but recommended fields
            if 'conflict' not in parsed:
                validation_result["warnings"].append("No conflict resolution strategy specified, using default 'overwrite'")
            
            if 'batch_size' not in parsed:
                validation_result["warnings"].append("No batch size specified, using default 1000")
            
            if 'parallel_jobs' not in parsed:
                validation_result["warnings"].append("No parallel jobs specified, using default 1")
            
            return validation_result
            
        except yaml.YAMLError as e:
            return {
                "valid": False,
                "errors": [f"YAML syntax error: {e}"],
                "warnings": []
            }
        except ValueError as e:
            return {
                "valid": False,
                "errors": [str(e)],
                "warnings": []
            }
        except Exception as e:
            return {
                "valid": False,
                "errors": [f"Validation error: {e}"],
                "warnings": []
            }
