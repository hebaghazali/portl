"""
YAML generator service for creating migration configuration files.

This service converts wizard responses and configuration dictionaries
into properly formatted YAML migration job files.
"""

from typing import Dict, Any, List
import yaml
from datetime import datetime
from pathlib import Path
from rich.console import Console
from rich.panel import Panel
from rich.table import Table

from ..schema import SchemaValidator


class YamlGenerator:
    """Generates YAML configuration files from wizard responses."""
    
    def __init__(self):
        self.console = Console()
    
    def generate_yaml(self, config: Dict[str, Any]) -> str:
        """
        Generate a YAML configuration file from wizard responses.
        
        Args:
            config: Configuration dictionary from wizard
            
        Returns:
            str: Formatted YAML content
        """
        # Create the YAML structure
        yaml_config = self._build_yaml_structure(config)
        
        # Generate YAML with comments
        yaml_content = self._generate_yaml_with_comments(yaml_config)
        
        return yaml_content
    
    def _build_yaml_structure(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Build the YAML structure from configuration."""
        yaml_config = {}
        
        # Add metadata
        yaml_config['# Generated by Portl Interactive Wizard'] = None
        yaml_config['# Created at'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        # Source configuration
        if 'source' in config:
            yaml_config['source'] = self._clean_config_section(config['source'])
        
        # Destination configuration
        if 'destination' in config:
            yaml_config['destination'] = self._clean_config_section(config['destination'])
        
        # Processing configuration
        if 'conflict' in config:
            yaml_config['conflict'] = config['conflict']
        
        if 'batch_size' in config:
            yaml_config['batch_size'] = config['batch_size']
        
        # Optional advanced configurations
        if 'schema_mapping' in config and config['schema_mapping']:
            yaml_config['schema_mapping'] = config['schema_mapping']
        
        if 'transformations' in config and config['transformations']:
            yaml_config['transformations'] = config['transformations']
        
        if 'hooks' in config and config['hooks']:
            yaml_config['hooks'] = config['hooks']
        
        # Add default parallel jobs if not specified
        if 'parallel_jobs' not in yaml_config:
            yaml_config['parallel_jobs'] = 1
        
        return yaml_config
    
    def _clean_config_section(self, section: Dict[str, Any]) -> Dict[str, Any]:
        """Clean and organize a configuration section."""
        cleaned = {}
        
        # Always put type first
        if 'type' in section:
            cleaned['type'] = section['type']
        
        # Add other keys in logical order
        key_order = [
            'host', 'port', 'database', 'username', 'password', 'schema', 'table', 'query',
            'path', 'spreadsheet_id', 'sheet_name', 'credentials_path'
        ]
        
        for key in key_order:
            if key in section:
                cleaned[key] = section[key]
        
        # Add any remaining keys
        for key, value in section.items():
            if key not in cleaned:
                cleaned[key] = value
        
        return cleaned
    
    def _generate_yaml_with_comments(self, config: Dict[str, Any]) -> str:
        """Generate YAML with helpful comments."""
        lines = []
        
        # Header comment
        lines.append("# Portl Migration Job Configuration")
        lines.append("# Generated by Interactive Wizard")
        lines.append(f"# Created: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        lines.append("")
        
        # Source section
        if 'source' in config:
            lines.append("# Source: Where to read data FROM")
            lines.extend(self._yaml_section_to_lines('source', config['source']))
            lines.append("")
        
        # Destination section
        if 'destination' in config:
            lines.append("# Destination: Where to write data TO")
            lines.extend(self._yaml_section_to_lines('destination', config['destination']))
            lines.append("")
        
        # Processing configuration
        lines.append("# Processing Configuration")
        
        if 'conflict' in config:
            lines.append("# How to handle conflicts when records already exist")
            lines.append("# Options: overwrite, skip, fail, merge")
            lines.append(f"conflict: {config['conflict']}")
            lines.append("")
        
        if 'batch_size' in config:
            lines.append("# Number of rows to process in each batch")
            lines.append(f"batch_size: {config['batch_size']}")
            lines.append("")
        
        if 'parallel_jobs' in config:
            lines.append("# Number of parallel processing jobs")
            lines.append(f"parallel_jobs: {config['parallel_jobs']}")
            lines.append("")
        
        # Optional sections
        if 'schema_mapping' in config:
            lines.append("# Column Mapping: source_column -> destination_column")
            lines.extend(self._yaml_section_to_lines('schema_mapping', config['schema_mapping']))
            lines.append("")
        
        if 'transformations' in config:
            lines.append("# Data Transformations")
            lines.extend(self._yaml_section_to_lines('transformations', config['transformations']))
            lines.append("")
        
        if 'hooks' in config:
            lines.append("# Processing Hooks: Scripts to run at different stages")
            lines.extend(self._yaml_section_to_lines('hooks', config['hooks']))
            lines.append("")
        
        return '\n'.join(lines)
    
    def _yaml_section_to_lines(self, section_name: str, section_data: Any) -> List[str]:
        """Convert a section to YAML lines."""
        # Use PyYAML to generate the section
        section_yaml = yaml.dump({section_name: section_data}, default_flow_style=False, sort_keys=False)
        
        # Split into lines and return (excluding the first line which is just the section name)
        lines = section_yaml.strip().split('\n')
        return lines
    
    def validate_generated_yaml(self, yaml_content: str) -> Dict[str, Any]:
        """
        Validate the generated YAML content using the schema validator.
        
        Args:
            yaml_content: YAML content to validate
            
        Returns:
            Dict with validation results
        """
        try:
            # Parse YAML to check syntax
            parsed = yaml.safe_load(yaml_content)
            
            if not parsed:
                return {
                    "valid": False,
                    "errors": ["YAML content is empty"],
                    "warnings": []
                }
            
            # Use the schema validator for comprehensive validation
            job_config = SchemaValidator.validate_yaml_config(parsed)
            
            # If we get here, validation passed
            validation_result = {
                "valid": True,
                "errors": [],
                "warnings": []
            }
            
            # Add warnings for missing optional but recommended fields
            if 'conflict' not in parsed:
                validation_result["warnings"].append("No conflict resolution strategy specified, using default 'overwrite'")
            
            if 'batch_size' not in parsed:
                validation_result["warnings"].append("No batch size specified, using default 1000")
            
            if 'parallel_jobs' not in parsed:
                validation_result["warnings"].append("No parallel jobs specified, using default 1")
            
            return validation_result
            
        except yaml.YAMLError as e:
            return {
                "valid": False,
                "errors": [f"YAML syntax error: {e}"],
                "warnings": []
            }
        except ValueError as e:
            return {
                "valid": False,
                "errors": [str(e)],
                "warnings": []
            }
        except Exception as e:
            return {
                "valid": False,
                "errors": [f"Validation error: {e}"],
                "warnings": []
            }
    
    def generate_job_plan_preview(self, config: Dict[str, Any]) -> str:
        """
        Generate a human-readable job plan preview.
        
        Args:
            config: Configuration dictionary
            
        Returns:
            str: Formatted job plan description
        """
        lines = []
        lines.append("Migration Job Plan")
        lines.append("=" * 50)
        
        # Source information
        if 'source' in config:
            source = config['source']
            lines.append(f"\nSource: {source.get('type', 'Unknown').upper()}")
            if source.get('type') == 'csv':
                lines.append(f"   File: {source.get('path', 'N/A')}")
            elif source.get('type') in ['postgres', 'mysql']:
                lines.append(f"   Host: {source.get('host', 'N/A')}")
                lines.append(f"   Database: {source.get('database', 'N/A')}")
                lines.append(f"   Table/Query: {source.get('table') or source.get('query', 'N/A')}")
            elif source.get('type') == 'google_sheets':
                lines.append(f"   Spreadsheet ID: {source.get('spreadsheet_id', 'N/A')}")
                lines.append(f"   Sheet: {source.get('sheet_name', 'N/A')}")
        
        # Destination information
        if 'destination' in config:
            dest = config['destination']
            lines.append(f"\nDestination: {dest.get('type', 'Unknown').upper()}")
            if dest.get('type') == 'csv':
                lines.append(f"   File: {dest.get('path', 'N/A')}")
            elif dest.get('type') in ['postgres', 'mysql']:
                lines.append(f"   Host: {dest.get('host', 'N/A')}")
                lines.append(f"   Database: {dest.get('database', 'N/A')}")
                lines.append(f"   Table: {dest.get('table', 'N/A')}")
            elif dest.get('type') == 'google_sheets':
                lines.append(f"   Spreadsheet ID: {dest.get('spreadsheet_id', 'N/A')}")
                lines.append(f"   Sheet: {dest.get('sheet_name', 'N/A')}")
        
        # Processing configuration
        lines.append(f"\nProcessing Configuration:")
        lines.append(f"   Conflict Strategy: {config.get('conflict', 'overwrite')}")
        lines.append(f"   Batch Size: {config.get('batch_size', 1000)} rows")
        lines.append(f"   Parallel Jobs: {config.get('parallel_jobs', 1)}")
        
        # Optional configurations
        if config.get('schema_mapping'):
            lines.append(f"\nColumn Mapping:")
            for source_col, dest_col in config['schema_mapping'].items():
                lines.append(f"   {source_col} -> {dest_col}")
        
        if config.get('transformations'):
            lines.append(f"\nData Transformations:")
            for transform in config['transformations']:
                lines.append(f"   {transform.get('column', 'N/A')}: {transform.get('operation', 'N/A')}")
        
        if config.get('hooks'):
            lines.append(f"\nProcessing Hooks:")
            hooks = config['hooks']
            for hook_type, hook_value in hooks.items():
                if hook_value:
                    lines.append(f"   {hook_type}: {hook_value}")
        
        return '\n'.join(lines)
    
    def display_job_plan_preview(self, config: Dict[str, Any]) -> None:
        """
        Display a formatted job plan preview.
        
        Args:
            config: Configuration dictionary
        """
        plan = self.generate_job_plan_preview(config)
        panel = Panel(plan, title="[bold green]Job Plan Preview[/bold green]", border_style="green")
        self.console.print(panel)
    
    def save_yaml_with_mode_handling(self, 
                                   yaml_content: str, 
                                   output_path: Path, 
                                   overwrite: bool = False) -> bool:
        """
        Save YAML content with proper mode handling (overwrite vs append).
        
        Args:
            yaml_content: YAML content to save
            output_path: Path where to save the file
            overwrite: Whether to overwrite existing file without asking
            
        Returns:
            bool: True if file was saved successfully
        """
        if output_path.exists() and not overwrite:
            # File exists, ask user what to do
            self.console.print(f"\n[yellow]File already exists: {output_path}[/yellow]")
            
            table = Table(show_header=False, box=None)
            table.add_row("[1]", "Overwrite existing file")
            table.add_row("[2]", "Create backup and overwrite")
            table.add_row("[3]", "Choose different filename")
            table.add_row("[4]", "Cancel")
            
            self.console.print(table)
            
            while True:
                choice = self.console.input("\nChoose an option [1-4]: ").strip()
                
                if choice == "1":
                    # Overwrite
                    break
                elif choice == "2":
                    # Create backup
                    backup_path = output_path.with_suffix(f"{output_path.suffix}.backup")
                    output_path.rename(backup_path)
                    self.console.print(f"[green]Backup created: {backup_path}[/green]")
                    break
                elif choice == "3":
                    # Choose different filename
                    new_name = self.console.input("Enter new filename: ").strip()
                    if new_name:
                        output_path = output_path.parent / new_name
                        if not output_path.suffix:
                            output_path = output_path.with_suffix('.yaml')
                    break
                elif choice == "4":
                    # Cancel
                    self.console.print("[yellow]Save cancelled.[/yellow]")
                    return False
                else:
                    self.console.print("[red]Invalid choice. Please enter 1-4.[/red]")
        
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(yaml_content)
            
            self.console.print(f"[green]✅ YAML configuration saved: {output_path}[/green]")
            return True
            
        except Exception as e:
            self.console.print(f"[red]❌ Failed to save file: {e}[/red]")
            return False
    
    def generate_and_preview_yaml(self, config: Dict[str, Any], show_preview: bool = True) -> str:
        """
        Generate YAML and optionally show preview with syntax highlighting.
        
        Args:
            config: Configuration dictionary
            show_preview: Whether to display the preview
            
        Returns:
            str: Generated YAML content
        """
        # Generate YAML content
        yaml_content = self.generate_yaml(config)
        
        if show_preview:
            # Show job plan preview
            self.display_job_plan_preview(config)
            self.console.print()  # Add spacing
        
        return yaml_content
    
    def display_validation_results(self, validation_result: Dict[str, Any]) -> None:
        """
        Display YAML validation results with formatted error reporting.
        
        Args:
            validation_result: Result from validate_generated_yaml()
        """
        if validation_result['valid']:
            self.console.print("[green]YAML validation passed![/green]")
            
            if validation_result.get('warnings'):
                self.console.print("\n[yellow]Warnings:[/yellow]")
                for warning in validation_result['warnings']:
                    self.console.print(f"  - {warning}")
        else:
            self.console.print("[red]YAML validation failed![/red]")
            
            if validation_result.get('errors'):
                self.console.print("\n[red]Errors:[/red]")
                for error in validation_result['errors']:
                    self.console.print(f"  - {error}")
            
            if validation_result.get('warnings'):
                self.console.print("\n[yellow]Warnings:[/yellow]")
                for warning in validation_result['warnings']:
                    self.console.print(f"  - {warning}")
    
    def validate_and_report_yaml(self, yaml_content: str) -> bool:
        """
        Validate YAML content and display formatted results.
        
        Args:
            yaml_content: YAML content to validate
            
        Returns:
            bool: True if validation passed
        """
        validation_result = self.validate_generated_yaml(yaml_content)
        self.display_validation_results(validation_result)
        return validation_result['valid']
